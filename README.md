# 23种设计模式

## 单例模式 singleton
**包含内容**
* 1、饿汉式单例
* 2、懒汉式单例
* 2.1 内部类单例 (个人觉得这种写法意义不大，就没写)
* 3、枚举单例

## 策略模式 strategy
**官方描述：** 定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户<br/>

**包含内容**
* strategy1 包中应该是我们平时最直接能想到的写法<br/>
  需要思考的是：并不是所有的鸭子都会游泳，所以显然这种设计是有问题
* strategy2 包中为修改之后的设计<br/>
  现象：这样设计的话，就算有些鸭子不会游泳也没有关系，只要会游泳的鸭子去实现SwimAble接口就好了<br/>
  需要思考的是：假如DuckC、DuckD、DuckE...的游泳行为都是一样的，这样势必会造成代码的不可复用性(java8之前，接口是没有默认实现方法的)，那么怎样才能既满足扩展性，又满足代码的复用性呢？
* strategy3 包中为修改之后的设计<br/>
  现象：
  1、我们在创建具体的Duck实例的时候，在构造方法中指定SwimAble的实现对象，在调用Duck实例的swim方法的时候，实际调用的是SwimAble实现对象的swim方法<br/>
  2、这样一来，就算有一万个Duck实例的swim动作都是一样，也没问题，在创建的时候都给他赋值同一个SwimAble的实现对象即可<br/>
  3、就算有鸭子是不会游泳的，也只要在创建的时候给他赋值Swim2即可，在调用swim方法的时候，啥也不干
  
## 观察者模式 observer
**官方描述：** 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态的时候，他的所有一来者都会收到通知并自动更新

**现实中的案例：** 报纸订阅，天气预报订阅，消息中间件的广播模式等

**包含内容：**
* observer1 包中user1和user2都订阅了天气预报<br/>
  现象与思考：这样写虽然能实现我们需要的发布订阅，但是有两个问题需要考虑<br/>
  第一就是我user1不想订阅了，这个时候就必须要改WeatherStation的代码，不去通知user1(即：user1得打电话求助一下气象站的人，让他帮忙处理一下，别再给我发消息了)<br/>
  第二就是user1得知天气预报的方法发生了变化，比如方法名字变了(实际应用比如：通知的接口地址发生了变化)，这个时候也必须要改WeatherStation的代码<br/>
* observer2 包中采用了观察者模式<br/>
  WeatherStation将变成一个主题Subject，他只管理订阅他的列表，不再关心具体谁订阅他，并且提供了关注与取消关注的功能给外部<br/>
  user1和user2将变成一个观察者，可以直接使用关注和取消关注的功能，不再需要打电话给气象站的人帮忙处理了
       



