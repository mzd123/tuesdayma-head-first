# 23种设计模式

## 单例模式 singleton
**包含内容**
* 1、饿汉式单例
* 2、懒汉式单例
* 2.1 内部类单例 (个人觉得这种写法意义不大，就没写)
* 3、枚举单例

## 策略模式 strategy
**官方描述：** 定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户<br/>

**包含内容**
* strategy1 包中应该是我们平时最直接能想到的写法<br/>
  需要思考的是：并不是所有的鸭子都会游泳，所以显然这种设计是有问题
* strategy2 包中为修改之后的设计<br/>
  现象：这样设计的话，就算有些鸭子不会游泳也没有关系，只要会游泳的鸭子去实现SwimAble接口就好了<br/>
  需要思考的是：假如DuckC、DuckD、DuckE...的游泳行为都是一样的，这样势必会造成代码的不可复用性(java8之前，接口是没有默认实现方法的)，那么怎样才能既满足扩展性，又满足代码的复用性呢？
* strategy3 包中为修改之后的设计<br/>
  现象：
  1、我们在创建具体的Duck实例的时候，在构造方法中指定SwimAble的实现对象，在调用Duck实例的swim方法的时候，实际调用的是SwimAble实现对象的swim方法<br/>
  2、这样一来，就算有一万个Duck实例的swim动作都是一样，也没问题，在创建的时候都给他赋值同一个SwimAble的实现对象即可<br/>
  3、就算有鸭子是不会游泳的，也只要在创建的时候给他赋值Swim2即可，在调用swim方法的时候，啥也不干
  
## 观察者模式 observer
**官方描述：** 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态的时候，他的所有一来者都会收到通知并自动更新

**现实中的案例：** 报纸订阅，天气预报订阅，消息中间件的广播模式等

**包含内容：**
* observer1 包中user1和user2都订阅了天气预报<br/>
  现象与思考：这样写虽然能实现我们需要的发布订阅，但是有两个问题需要考虑<br/>
  第一就是我user1不想订阅了，这个时候就必须要改WeatherStation的代码，不去通知user1(即：user1得打电话求助一下气象站的人，让他帮忙处理一下，别再给我发消息了)<br/>
  第二就是user1得知天气预报的方法发生了变化，比如方法名字变了(实际应用比如：通知的接口地址发生了变化)，这个时候也必须要改WeatherStation的代码<br/>
* observer2 包中采用了观察者模式<br/>
  WeatherStation将变成一个主题Subject，他只管理订阅他的列表，不再关心具体谁订阅他，并且提供了关注与取消关注的功能给外部<br/>
  user1和user2将变成一个观察者，可以直接使用关注和取消关注的功能，不再需要打电话给气象站的人帮忙处理了
  
## 装饰模式 decorator
**官方描述：** 动态的将责任附加到对象上，若要扩展功能，装饰着提供了比继承更有弹性的替代方案<br/>

**现实中的案例：** 

* 清汤面、鸡蛋面(面+鸡蛋)、大排面(面+大排)、大排鸡蛋面(面+鸡蛋+大排)....<br/>
* java中的i/o

**包含内容：**
* decorator1 包中Noodle为一碗清汤面，厨师可以根据顾客的需求不断的往里面加佐料，同时，这个面的名字和价格都会发生变化。<br/>
  思考：在佐料少的情况下，这样的写法貌似没啥问题，我只有大排和鸡蛋可以加的话，也就产生了几个类而已。但是如果佐料的情况越来越多的时候，会产生两个问题：<br/>
  1、能产生的面的种类将成排列组合形式增多，那需要维护类的数量将变得越来越多，形成了类爆炸<br/>
  2、假如这个时候猪肉价格上涨了，那么所有含有大排的面，价格都要发生改变,即PorkChop、NoodleWithPorkChop和NoodleWithPorkChopAndEgg的getPrice方法都要发生改变<br/>
* decorator2 包中FoodDecorator为装饰类的父类，EggDecorator和PorkChopDecorator为装饰类，Noodle为被装饰的类<br/>
  现象：<br/>
  1、类不在爆炸式增加，有多少个佐料，就会增加多少个类，而不是想decorator1中这样排列组合式增加了
  2、就算猪肉在涨价，我们只要改变PorkChopDecorator中的价格即可，其他类中的价格将不在受影响

**感悟：**

* decorator1的场景更像是顾客在选择已经做好了的套餐(茶树菇老鸦、鱼香肉丝、西红柿鸡蛋盖浇饭...)，如果要茶树菇鸡蛋饭，不好意思，没有现成的，需要新建一个类才能满足<br/>
  decorator2中用的装饰模式更像是食堂打饭，这个菜来一点，那个菜来一点，更加灵活
* 在我们的jdk中也有装饰模式，典型的例子i/o:<br/>
  OutputStream 是最原始的抽象组件对象<br/>
  FileOutputStream 是被装饰类<br/>
  FilterOutputStream 是装饰类的父类<br/>
  BufferedOutputStream 和 DataOutputStream等是装饰类<br/>




